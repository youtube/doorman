// Copyright 2016 Google, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go.
// source: doorman.proto
// DO NOT EDIT!

/*
Package doorman is a generated protocol buffer package.

It is generated from these files:
	doorman.proto

It has these top-level messages:
	Lease
	ResourceRequest
	GetCapacityRequest
	ResourceResponse
	Mastership
	GetCapacityResponse
	PriorityBandAggregate
	ServerCapacityResourceRequest
	GetServerCapacityRequest
	ServerCapacityResourceResponse
	GetServerCapacityResponse
	ReleaseCapacityRequest
	ReleaseCapacityResponse
	NamedParameter
	Algorithm
	ResourceTemplate
	ResourceRepository
	DiscoveryRequest
	DiscoveryResponse
*/
package doorman

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

type Algorithm_Kind int32

const (
	Algorithm_NO_ALGORITHM       Algorithm_Kind = 0
	Algorithm_STATIC             Algorithm_Kind = 1
	Algorithm_PROPORTIONAL_SHARE Algorithm_Kind = 2
	Algorithm_FAIR_SHARE         Algorithm_Kind = 3
)

var Algorithm_Kind_name = map[int32]string{
	0: "NO_ALGORITHM",
	1: "STATIC",
	2: "PROPORTIONAL_SHARE",
	3: "FAIR_SHARE",
}
var Algorithm_Kind_value = map[string]int32{
	"NO_ALGORITHM":       0,
	"STATIC":             1,
	"PROPORTIONAL_SHARE": 2,
	"FAIR_SHARE":         3,
}

func (x Algorithm_Kind) Enum() *Algorithm_Kind {
	p := new(Algorithm_Kind)
	*p = x
	return p
}
func (x Algorithm_Kind) String() string {
	return proto.EnumName(Algorithm_Kind_name, int32(x))
}
func (x *Algorithm_Kind) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Algorithm_Kind_value, data, "Algorithm_Kind")
	if err != nil {
		return err
	}
	*x = Algorithm_Kind(value)
	return nil
}
func (Algorithm_Kind) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{14, 0} }

// Encapsulates a lease on capacity with a expiry_time in seconds
// since the epoch.
type Lease struct {
	ExpiryTime       *int64   `protobuf:"varint,1,req,name=expiry_time" json:"expiry_time,omitempty"`
	RefreshInterval  *int64   `protobuf:"varint,2,req,name=refresh_interval" json:"refresh_interval,omitempty"`
	Capacity         *float64 `protobuf:"fixed64,3,req,name=capacity" json:"capacity,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Lease) Reset()                    { *m = Lease{} }
func (m *Lease) String() string            { return proto.CompactTextString(m) }
func (*Lease) ProtoMessage()               {}
func (*Lease) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Lease) GetExpiryTime() int64 {
	if m != nil && m.ExpiryTime != nil {
		return *m.ExpiryTime
	}
	return 0
}

func (m *Lease) GetRefreshInterval() int64 {
	if m != nil && m.RefreshInterval != nil {
		return *m.RefreshInterval
	}
	return 0
}

func (m *Lease) GetCapacity() float64 {
	if m != nil && m.Capacity != nil {
		return *m.Capacity
	}
	return 0
}

// Encapsulates the information we need to send to get capacity for a
// single resource.
type ResourceRequest struct {
	ResourceId       *string  `protobuf:"bytes,1,req,name=resource_id" json:"resource_id,omitempty"`
	Priority         *int64   `protobuf:"varint,2,req,name=priority" json:"priority,omitempty"`
	Has              *Lease   `protobuf:"bytes,3,opt,name=has" json:"has,omitempty"`
	Wants            *float64 `protobuf:"fixed64,4,req,name=wants" json:"wants,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ResourceRequest) Reset()                    { *m = ResourceRequest{} }
func (m *ResourceRequest) String() string            { return proto.CompactTextString(m) }
func (*ResourceRequest) ProtoMessage()               {}
func (*ResourceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ResourceRequest) GetResourceId() string {
	if m != nil && m.ResourceId != nil {
		return *m.ResourceId
	}
	return ""
}

func (m *ResourceRequest) GetPriority() int64 {
	if m != nil && m.Priority != nil {
		return *m.Priority
	}
	return 0
}

func (m *ResourceRequest) GetHas() *Lease {
	if m != nil {
		return m.Has
	}
	return nil
}

func (m *ResourceRequest) GetWants() float64 {
	if m != nil && m.Wants != nil {
		return *m.Wants
	}
	return 0
}

// The GetCapacityRequest contains the identifier of the client making
// the request and a list of single resource capacity request protocol
// buffers.
type GetCapacityRequest struct {
	ClientId         *string            `protobuf:"bytes,1,req,name=client_id" json:"client_id,omitempty"`
	Resource         []*ResourceRequest `protobuf:"bytes,2,rep,name=resource" json:"resource,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *GetCapacityRequest) Reset()                    { *m = GetCapacityRequest{} }
func (m *GetCapacityRequest) String() string            { return proto.CompactTextString(m) }
func (*GetCapacityRequest) ProtoMessage()               {}
func (*GetCapacityRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *GetCapacityRequest) GetClientId() string {
	if m != nil && m.ClientId != nil {
		return *m.ClientId
	}
	return ""
}

func (m *GetCapacityRequest) GetResource() []*ResourceRequest {
	if m != nil {
		return m.Resource
	}
	return nil
}

// Contains the capacity allocated by the server for a single
// resource.
type ResourceResponse struct {
	ResourceId       *string  `protobuf:"bytes,1,req,name=resource_id" json:"resource_id,omitempty"`
	Gets             *Lease   `protobuf:"bytes,2,req,name=gets" json:"gets,omitempty"`
	SafeCapacity     *float64 `protobuf:"fixed64,3,opt,name=safe_capacity" json:"safe_capacity,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ResourceResponse) Reset()                    { *m = ResourceResponse{} }
func (m *ResourceResponse) String() string            { return proto.CompactTextString(m) }
func (*ResourceResponse) ProtoMessage()               {}
func (*ResourceResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ResourceResponse) GetResourceId() string {
	if m != nil && m.ResourceId != nil {
		return *m.ResourceId
	}
	return ""
}

func (m *ResourceResponse) GetGets() *Lease {
	if m != nil {
		return m.Gets
	}
	return nil
}

func (m *ResourceResponse) GetSafeCapacity() float64 {
	if m != nil && m.SafeCapacity != nil {
		return *m.SafeCapacity
	}
	return 0
}

// This message type is used when the server wants to convey the
// address of a master. If the the optional master_address field
// is not there that means that the server wants to tell us who
// the master is, but it doesn't know.
type Mastership struct {
	MasterAddress    *string `protobuf:"bytes,1,opt,name=master_address" json:"master_address,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Mastership) Reset()                    { *m = Mastership{} }
func (m *Mastership) String() string            { return proto.CompactTextString(m) }
func (*Mastership) ProtoMessage()               {}
func (*Mastership) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Mastership) GetMasterAddress() string {
	if m != nil && m.MasterAddress != nil {
		return *m.MasterAddress
	}
	return ""
}

// The response to a GetCapacity request is a list of protocol buffers
// specifying the capacity for a single resource.
// If the mastership field is there the server is telling us that it is
// not the master. The new master is in the mastership message, unless
// the server does not know who the master is, in which case the
// mastership field will be there, but the master_address field in it will
// be empty.
type GetCapacityResponse struct {
	Response         []*ResourceResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
	Mastership       *Mastership         `protobuf:"bytes,2,opt,name=mastership" json:"mastership,omitempty"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *GetCapacityResponse) Reset()                    { *m = GetCapacityResponse{} }
func (m *GetCapacityResponse) String() string            { return proto.CompactTextString(m) }
func (*GetCapacityResponse) ProtoMessage()               {}
func (*GetCapacityResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *GetCapacityResponse) GetResponse() []*ResourceResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *GetCapacityResponse) GetMastership() *Mastership {
	if m != nil {
		return m.Mastership
	}
	return nil
}

type PriorityBandAggregate struct {
	Priority         *int64   `protobuf:"varint,1,req,name=priority" json:"priority,omitempty"`
	NumClients       *int64   `protobuf:"varint,2,req,name=num_clients" json:"num_clients,omitempty"`
	Wants            *float64 `protobuf:"fixed64,3,req,name=wants" json:"wants,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *PriorityBandAggregate) Reset()                    { *m = PriorityBandAggregate{} }
func (m *PriorityBandAggregate) String() string            { return proto.CompactTextString(m) }
func (*PriorityBandAggregate) ProtoMessage()               {}
func (*PriorityBandAggregate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *PriorityBandAggregate) GetPriority() int64 {
	if m != nil && m.Priority != nil {
		return *m.Priority
	}
	return 0
}

func (m *PriorityBandAggregate) GetNumClients() int64 {
	if m != nil && m.NumClients != nil {
		return *m.NumClients
	}
	return 0
}

func (m *PriorityBandAggregate) GetWants() float64 {
	if m != nil && m.Wants != nil {
		return *m.Wants
	}
	return 0
}

type ServerCapacityResourceRequest struct {
	ResourceId       *string                  `protobuf:"bytes,1,req,name=resource_id" json:"resource_id,omitempty"`
	Has              *Lease                   `protobuf:"bytes,2,opt,name=has" json:"has,omitempty"`
	Wants            []*PriorityBandAggregate `protobuf:"bytes,3,rep,name=wants" json:"wants,omitempty"`
	XXX_unrecognized []byte                   `json:"-"`
}

func (m *ServerCapacityResourceRequest) Reset()                    { *m = ServerCapacityResourceRequest{} }
func (m *ServerCapacityResourceRequest) String() string            { return proto.CompactTextString(m) }
func (*ServerCapacityResourceRequest) ProtoMessage()               {}
func (*ServerCapacityResourceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *ServerCapacityResourceRequest) GetResourceId() string {
	if m != nil && m.ResourceId != nil {
		return *m.ResourceId
	}
	return ""
}

func (m *ServerCapacityResourceRequest) GetHas() *Lease {
	if m != nil {
		return m.Has
	}
	return nil
}

func (m *ServerCapacityResourceRequest) GetWants() []*PriorityBandAggregate {
	if m != nil {
		return m.Wants
	}
	return nil
}

type GetServerCapacityRequest struct {
	ServerId         *string                          `protobuf:"bytes,1,req,name=server_id" json:"server_id,omitempty"`
	Resource         []*ServerCapacityResourceRequest `protobuf:"bytes,2,rep,name=resource" json:"resource,omitempty"`
	XXX_unrecognized []byte                           `json:"-"`
}

func (m *GetServerCapacityRequest) Reset()                    { *m = GetServerCapacityRequest{} }
func (m *GetServerCapacityRequest) String() string            { return proto.CompactTextString(m) }
func (*GetServerCapacityRequest) ProtoMessage()               {}
func (*GetServerCapacityRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *GetServerCapacityRequest) GetServerId() string {
	if m != nil && m.ServerId != nil {
		return *m.ServerId
	}
	return ""
}

func (m *GetServerCapacityRequest) GetResource() []*ServerCapacityResourceRequest {
	if m != nil {
		return m.Resource
	}
	return nil
}

type ServerCapacityResourceResponse struct {
	ResourceId       *string    `protobuf:"bytes,1,req,name=resource_id" json:"resource_id,omitempty"`
	Gets             *Lease     `protobuf:"bytes,2,req,name=gets" json:"gets,omitempty"`
	Algorithm        *Algorithm `protobuf:"bytes,3,opt,name=algorithm" json:"algorithm,omitempty"`
	SafeCapacity     *float64   `protobuf:"fixed64,4,opt,name=safe_capacity" json:"safe_capacity,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *ServerCapacityResourceResponse) Reset()                    { *m = ServerCapacityResourceResponse{} }
func (m *ServerCapacityResourceResponse) String() string            { return proto.CompactTextString(m) }
func (*ServerCapacityResourceResponse) ProtoMessage()               {}
func (*ServerCapacityResourceResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *ServerCapacityResourceResponse) GetResourceId() string {
	if m != nil && m.ResourceId != nil {
		return *m.ResourceId
	}
	return ""
}

func (m *ServerCapacityResourceResponse) GetGets() *Lease {
	if m != nil {
		return m.Gets
	}
	return nil
}

func (m *ServerCapacityResourceResponse) GetAlgorithm() *Algorithm {
	if m != nil {
		return m.Algorithm
	}
	return nil
}

func (m *ServerCapacityResourceResponse) GetSafeCapacity() float64 {
	if m != nil && m.SafeCapacity != nil {
		return *m.SafeCapacity
	}
	return 0
}

// The response to a GetServerCapacity request is a list of protocol buffers
// specifying the capacity for a single resource.
// If the mastership field is there the server is telling us that it is
// not the master. The new master is in the mastership message, unless
// the server does not know who the master is, in which case the
// mastership field will be there, but the master_address field in it will
// be empty.
type GetServerCapacityResponse struct {
	Response         []*ServerCapacityResourceResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
	Mastership       *Mastership                       `protobuf:"bytes,2,opt,name=mastership" json:"mastership,omitempty"`
	XXX_unrecognized []byte                            `json:"-"`
}

func (m *GetServerCapacityResponse) Reset()                    { *m = GetServerCapacityResponse{} }
func (m *GetServerCapacityResponse) String() string            { return proto.CompactTextString(m) }
func (*GetServerCapacityResponse) ProtoMessage()               {}
func (*GetServerCapacityResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *GetServerCapacityResponse) GetResponse() []*ServerCapacityResourceResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *GetServerCapacityResponse) GetMastership() *Mastership {
	if m != nil {
		return m.Mastership
	}
	return nil
}

// The ReleaseCapacity RPC instructs the server to release all leases
// that this client has on one or more resources. The lease is expected
// to expire as part of this RPC, so the client should not use the resource
// anymore.
type ReleaseCapacityRequest struct {
	ClientId         *string  `protobuf:"bytes,1,req,name=client_id" json:"client_id,omitempty"`
	ResourceId       []string `protobuf:"bytes,2,rep,name=resource_id" json:"resource_id,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ReleaseCapacityRequest) Reset()                    { *m = ReleaseCapacityRequest{} }
func (m *ReleaseCapacityRequest) String() string            { return proto.CompactTextString(m) }
func (*ReleaseCapacityRequest) ProtoMessage()               {}
func (*ReleaseCapacityRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *ReleaseCapacityRequest) GetClientId() string {
	if m != nil && m.ClientId != nil {
		return *m.ClientId
	}
	return ""
}

func (m *ReleaseCapacityRequest) GetResourceId() []string {
	if m != nil {
		return m.ResourceId
	}
	return nil
}

// A ReleaseCapacity RPC can only fail if the server we are talking to
// is not the master. In that case the mastership field indicates who
// the master is (if we know, if we don't know the mastership field will
// be there but the optional master_addres field inside mastership will
// not be there).
type ReleaseCapacityResponse struct {
	Mastership       *Mastership `protobuf:"bytes,1,opt,name=mastership" json:"mastership,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *ReleaseCapacityResponse) Reset()                    { *m = ReleaseCapacityResponse{} }
func (m *ReleaseCapacityResponse) String() string            { return proto.CompactTextString(m) }
func (*ReleaseCapacityResponse) ProtoMessage()               {}
func (*ReleaseCapacityResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *ReleaseCapacityResponse) GetMastership() *Mastership {
	if m != nil {
		return m.Mastership
	}
	return nil
}

// NamedParameter encapsulates a name/value pair which is used to
// configure an Algorithm (see below).
type NamedParameter struct {
	Name             *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Value            *string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *NamedParameter) Reset()                    { *m = NamedParameter{} }
func (m *NamedParameter) String() string            { return proto.CompactTextString(m) }
func (*NamedParameter) ProtoMessage()               {}
func (*NamedParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *NamedParameter) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *NamedParameter) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

type Algorithm struct {
	Kind *Algorithm_Kind `protobuf:"varint,1,req,name=kind,enum=doorman.Algorithm_Kind" json:"kind,omitempty"`
	// How long should the lease be, in seconds.
	LeaseLength *int64 `protobuf:"varint,2,req,name=lease_length" json:"lease_length,omitempty"`
	// How many seconds should the client wait until refreshing its
	// lease.
	RefreshInterval *int64            `protobuf:"varint,3,req,name=refresh_interval" json:"refresh_interval,omitempty"`
	Parameters      []*NamedParameter `protobuf:"bytes,4,rep,name=parameters" json:"parameters,omitempty"`
	// By default the learning mode duration is the lease length,
	// however if you want to live dangerously, and assume that
	// clients are living up to their responsibility to contact
	// the server every refresh_interval, you can specify a shorter
	// learning mode here. You can also specify a longer learning
	// mode duration (longer than the lease length), but then you
	// are a muppet (or you do not trust the clients, in which case
	// you need to fix the client implementation).
	LearningModeDuration *int64 `protobuf:"varint,5,opt,name=learning_mode_duration" json:"learning_mode_duration,omitempty"`
	XXX_unrecognized     []byte `json:"-"`
}

func (m *Algorithm) Reset()                    { *m = Algorithm{} }
func (m *Algorithm) String() string            { return proto.CompactTextString(m) }
func (*Algorithm) ProtoMessage()               {}
func (*Algorithm) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *Algorithm) GetKind() Algorithm_Kind {
	if m != nil && m.Kind != nil {
		return *m.Kind
	}
	return Algorithm_NO_ALGORITHM
}

func (m *Algorithm) GetLeaseLength() int64 {
	if m != nil && m.LeaseLength != nil {
		return *m.LeaseLength
	}
	return 0
}

func (m *Algorithm) GetRefreshInterval() int64 {
	if m != nil && m.RefreshInterval != nil {
		return *m.RefreshInterval
	}
	return 0
}

func (m *Algorithm) GetParameters() []*NamedParameter {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *Algorithm) GetLearningModeDuration() int64 {
	if m != nil && m.LearningModeDuration != nil {
		return *m.LearningModeDuration
	}
	return 0
}

// ResourceTemplate is used to instantiate the actual configuration
// for a resource based on a match with the identifier_glob glob.
type ResourceTemplate struct {
	// Glob used to match actual resources.
	IdentifierGlob *string `protobuf:"bytes,1,req,name=identifier_glob" json:"identifier_glob,omitempty"`
	// Capacity in service units
	Capacity *float64 `protobuf:"fixed64,2,req,name=capacity" json:"capacity,omitempty"`
	// Algorithm used to divide capacity between clients.
	Algorithm *Algorithm `protobuf:"bytes,3,req,name=algorithm" json:"algorithm,omitempty"`
	// Capacity to use in "safe" mode.
	// You can set this to a number and then the client will use that number
	// as the capacity in case it cannot refresh its lease.
	// If this field is absent the system returns a dynamic safe capacity in
	// the response, which is the available capacity divided by the number of
	// clients that the server knows about.
	SafeCapacity *float64 `protobuf:"fixed64,4,opt,name=safe_capacity" json:"safe_capacity,omitempty"`
	// Description of the resource.
	Description      *string `protobuf:"bytes,5,opt,name=description" json:"description,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ResourceTemplate) Reset()                    { *m = ResourceTemplate{} }
func (m *ResourceTemplate) String() string            { return proto.CompactTextString(m) }
func (*ResourceTemplate) ProtoMessage()               {}
func (*ResourceTemplate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *ResourceTemplate) GetIdentifierGlob() string {
	if m != nil && m.IdentifierGlob != nil {
		return *m.IdentifierGlob
	}
	return ""
}

func (m *ResourceTemplate) GetCapacity() float64 {
	if m != nil && m.Capacity != nil {
		return *m.Capacity
	}
	return 0
}

func (m *ResourceTemplate) GetAlgorithm() *Algorithm {
	if m != nil {
		return m.Algorithm
	}
	return nil
}

func (m *ResourceTemplate) GetSafeCapacity() float64 {
	if m != nil && m.SafeCapacity != nil {
		return *m.SafeCapacity
	}
	return 0
}

func (m *ResourceTemplate) GetDescription() string {
	if m != nil && m.Description != nil {
		return *m.Description
	}
	return ""
}

// The resource configuration consists of a list of templates.
type ResourceRepository struct {
	// List of ResourceTemplates specifying available resources. Order
	// of elements in this list is significant: it will be used to match
	// incoming requests. A template for * should be the last element.
	Resources        []*ResourceTemplate `protobuf:"bytes,1,rep,name=resources" json:"resources,omitempty"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *ResourceRepository) Reset()                    { *m = ResourceRepository{} }
func (m *ResourceRepository) String() string            { return proto.CompactTextString(m) }
func (*ResourceRepository) ProtoMessage()               {}
func (*ResourceRepository) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *ResourceRepository) GetResources() []*ResourceTemplate {
	if m != nil {
		return m.Resources
	}
	return nil
}

// The request to obtain the master's address.
type DiscoveryRequest struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *DiscoveryRequest) Reset()                    { *m = DiscoveryRequest{} }
func (m *DiscoveryRequest) String() string            { return proto.CompactTextString(m) }
func (*DiscoveryRequest) ProtoMessage()               {}
func (*DiscoveryRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

// The response containing the master's address.
type DiscoveryResponse struct {
	Mastership       *Mastership `protobuf:"bytes,1,req,name=mastership" json:"mastership,omitempty"`
	IsMaster         *bool       `protobuf:"varint,2,req,name=is_master" json:"is_master,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *DiscoveryResponse) Reset()                    { *m = DiscoveryResponse{} }
func (m *DiscoveryResponse) String() string            { return proto.CompactTextString(m) }
func (*DiscoveryResponse) ProtoMessage()               {}
func (*DiscoveryResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *DiscoveryResponse) GetMastership() *Mastership {
	if m != nil {
		return m.Mastership
	}
	return nil
}

func (m *DiscoveryResponse) GetIsMaster() bool {
	if m != nil && m.IsMaster != nil {
		return *m.IsMaster
	}
	return false
}

func init() {
	proto.RegisterType((*Lease)(nil), "doorman.Lease")
	proto.RegisterType((*ResourceRequest)(nil), "doorman.ResourceRequest")
	proto.RegisterType((*GetCapacityRequest)(nil), "doorman.GetCapacityRequest")
	proto.RegisterType((*ResourceResponse)(nil), "doorman.ResourceResponse")
	proto.RegisterType((*Mastership)(nil), "doorman.Mastership")
	proto.RegisterType((*GetCapacityResponse)(nil), "doorman.GetCapacityResponse")
	proto.RegisterType((*PriorityBandAggregate)(nil), "doorman.PriorityBandAggregate")
	proto.RegisterType((*ServerCapacityResourceRequest)(nil), "doorman.ServerCapacityResourceRequest")
	proto.RegisterType((*GetServerCapacityRequest)(nil), "doorman.GetServerCapacityRequest")
	proto.RegisterType((*ServerCapacityResourceResponse)(nil), "doorman.ServerCapacityResourceResponse")
	proto.RegisterType((*GetServerCapacityResponse)(nil), "doorman.GetServerCapacityResponse")
	proto.RegisterType((*ReleaseCapacityRequest)(nil), "doorman.ReleaseCapacityRequest")
	proto.RegisterType((*ReleaseCapacityResponse)(nil), "doorman.ReleaseCapacityResponse")
	proto.RegisterType((*NamedParameter)(nil), "doorman.NamedParameter")
	proto.RegisterType((*Algorithm)(nil), "doorman.Algorithm")
	proto.RegisterType((*ResourceTemplate)(nil), "doorman.ResourceTemplate")
	proto.RegisterType((*ResourceRepository)(nil), "doorman.ResourceRepository")
	proto.RegisterType((*DiscoveryRequest)(nil), "doorman.DiscoveryRequest")
	proto.RegisterType((*DiscoveryResponse)(nil), "doorman.DiscoveryResponse")
	proto.RegisterEnum("doorman.Algorithm_Kind", Algorithm_Kind_name, Algorithm_Kind_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for Capacity service

type CapacityClient interface {
	// Used by clients to discover the master Doorman server.
	Discovery(ctx context.Context, in *DiscoveryRequest, opts ...grpc.CallOption) (*DiscoveryResponse, error)
	// Used by clients to obtain capacity from Doorman.
	GetCapacity(ctx context.Context, in *GetCapacityRequest, opts ...grpc.CallOption) (*GetCapacityResponse, error)
	// Used by Doorman servers to get capacity on behalf of their clients from
	// lower level Doorman servers.
	GetServerCapacity(ctx context.Context, in *GetServerCapacityRequest, opts ...grpc.CallOption) (*GetServerCapacityResponse, error)
	// Used by clients to release any capacity they have for one or more
	// resources.
	ReleaseCapacity(ctx context.Context, in *ReleaseCapacityRequest, opts ...grpc.CallOption) (*ReleaseCapacityResponse, error)
}

type capacityClient struct {
	cc *grpc.ClientConn
}

func NewCapacityClient(cc *grpc.ClientConn) CapacityClient {
	return &capacityClient{cc}
}

func (c *capacityClient) Discovery(ctx context.Context, in *DiscoveryRequest, opts ...grpc.CallOption) (*DiscoveryResponse, error) {
	out := new(DiscoveryResponse)
	err := grpc.Invoke(ctx, "/doorman.Capacity/Discovery", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *capacityClient) GetCapacity(ctx context.Context, in *GetCapacityRequest, opts ...grpc.CallOption) (*GetCapacityResponse, error) {
	out := new(GetCapacityResponse)
	err := grpc.Invoke(ctx, "/doorman.Capacity/GetCapacity", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *capacityClient) GetServerCapacity(ctx context.Context, in *GetServerCapacityRequest, opts ...grpc.CallOption) (*GetServerCapacityResponse, error) {
	out := new(GetServerCapacityResponse)
	err := grpc.Invoke(ctx, "/doorman.Capacity/GetServerCapacity", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *capacityClient) ReleaseCapacity(ctx context.Context, in *ReleaseCapacityRequest, opts ...grpc.CallOption) (*ReleaseCapacityResponse, error) {
	out := new(ReleaseCapacityResponse)
	err := grpc.Invoke(ctx, "/doorman.Capacity/ReleaseCapacity", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Capacity service

type CapacityServer interface {
	// Used by clients to discover the master Doorman server.
	Discovery(context.Context, *DiscoveryRequest) (*DiscoveryResponse, error)
	// Used by clients to obtain capacity from Doorman.
	GetCapacity(context.Context, *GetCapacityRequest) (*GetCapacityResponse, error)
	// Used by Doorman servers to get capacity on behalf of their clients from
	// lower level Doorman servers.
	GetServerCapacity(context.Context, *GetServerCapacityRequest) (*GetServerCapacityResponse, error)
	// Used by clients to release any capacity they have for one or more
	// resources.
	ReleaseCapacity(context.Context, *ReleaseCapacityRequest) (*ReleaseCapacityResponse, error)
}

func RegisterCapacityServer(s *grpc.Server, srv CapacityServer) {
	s.RegisterService(&_Capacity_serviceDesc, srv)
}

func _Capacity_Discovery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DiscoveryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(CapacityServer).Discovery(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Capacity_GetCapacity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(GetCapacityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(CapacityServer).GetCapacity(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Capacity_GetServerCapacity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(GetServerCapacityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(CapacityServer).GetServerCapacity(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Capacity_ReleaseCapacity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ReleaseCapacityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(CapacityServer).ReleaseCapacity(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Capacity_serviceDesc = grpc.ServiceDesc{
	ServiceName: "doorman.Capacity",
	HandlerType: (*CapacityServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Discovery",
			Handler:    _Capacity_Discovery_Handler,
		},
		{
			MethodName: "GetCapacity",
			Handler:    _Capacity_GetCapacity_Handler,
		},
		{
			MethodName: "GetServerCapacity",
			Handler:    _Capacity_GetServerCapacity_Handler,
		},
		{
			MethodName: "ReleaseCapacity",
			Handler:    _Capacity_ReleaseCapacity_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

var fileDescriptor0 = []byte{
	// 962 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x56, 0xcd, 0x6e, 0x23, 0x45,
	0x10, 0x66, 0xc6, 0x0e, 0x78, 0xca, 0x89, 0xe3, 0xed, 0x5d, 0xb2, 0x5e, 0x2f, 0xec, 0x66, 0x07,
	0xc1, 0x2e, 0x42, 0x8a, 0x50, 0x58, 0x84, 0xc4, 0xcd, 0xc9, 0x42, 0x62, 0xe1, 0xc4, 0x51, 0xc7,
	0xe2, 0xc0, 0x65, 0x34, 0x78, 0x3a, 0xe3, 0x06, 0xcf, 0x0f, 0xdd, 0x63, 0x20, 0x82, 0x0b, 0x17,
	0xde, 0x00, 0x89, 0x87, 0xe1, 0xc6, 0x8d, 0x13, 0x8f, 0x44, 0xf5, 0x4c, 0xcf, 0x8f, 0xed, 0x71,
	0xd8, 0x48, 0x39, 0x25, 0xfd, 0x55, 0x4d, 0xd7, 0x57, 0x55, 0x5f, 0x75, 0x19, 0x76, 0xbc, 0x28,
	0x12, 0x81, 0x1b, 0x1e, 0xc4, 0x22, 0x4a, 0x22, 0xf2, 0x96, 0x3e, 0xda, 0x11, 0x6c, 0x8d, 0x98,
	0x2b, 0x19, 0x79, 0x0a, 0x6d, 0xf6, 0x73, 0xcc, 0xc5, 0xb5, 0x93, 0xf0, 0x80, 0xf5, 0x8c, 0x7d,
	0xf3, 0x45, 0x83, 0x42, 0x06, 0x4d, 0x10, 0x21, 0x1f, 0x42, 0x57, 0xb0, 0x2b, 0xc1, 0xe4, 0xcc,
	0xe1, 0x61, 0xc2, 0xc4, 0x8f, 0xee, 0xbc, 0x67, 0xa6, 0x5e, 0xbb, 0x1a, 0x1f, 0x6a, 0x98, 0xf4,
	0xa1, 0x35, 0x75, 0x63, 0x77, 0xca, 0x93, 0xeb, 0x5e, 0x03, 0x5d, 0x0c, 0x5a, 0x9c, 0xed, 0xdf,
	0x0d, 0xd8, 0xa5, 0x4c, 0x46, 0x0b, 0x31, 0x65, 0x94, 0xfd, 0xb0, 0x60, 0x32, 0x51, 0xb1, 0x85,
	0x86, 0x1c, 0xee, 0xa5, 0xb1, 0x2d, 0x0a, 0x39, 0x34, 0xf4, 0xd4, 0x85, 0xb1, 0xe0, 0x91, 0x50,
	0x17, 0x66, 0x31, 0x8b, 0x33, 0xd9, 0x87, 0xc6, 0xcc, 0x95, 0x18, 0xc7, 0x78, 0xd1, 0x3e, 0xec,
	0x1c, 0xe4, 0x79, 0xa6, 0x59, 0x51, 0x65, 0x22, 0x0f, 0x60, 0xeb, 0x27, 0x37, 0x4c, 0x64, 0xaf,
	0x99, 0x72, 0xc9, 0x0e, 0xb6, 0x0f, 0xe4, 0x84, 0x25, 0xc7, 0x9a, 0x57, 0x4e, 0xe5, 0x31, 0x58,
	0xd3, 0x39, 0x67, 0x61, 0x52, 0x12, 0x69, 0x65, 0x00, 0xd2, 0x78, 0x09, 0xad, 0x9c, 0x14, 0xd2,
	0x68, 0x60, 0xbc, 0x5e, 0x11, 0x6f, 0x25, 0x27, 0x5a, 0x78, 0xda, 0xbf, 0x42, 0xb7, 0x34, 0xca,
	0x38, 0x0a, 0xb3, 0x6a, 0xdf, 0x9c, 0xb1, 0x0d, 0x4d, 0x9f, 0x21, 0x65, 0x95, 0xed, 0x7a, 0x5a,
	0xa9, 0x8d, 0xbc, 0x07, 0x3b, 0xd2, 0xbd, 0x62, 0x4e, 0xa5, 0xd6, 0x06, 0xe6, 0xb7, 0xad, 0xc0,
	0x3c, 0x2f, 0xfb, 0x13, 0x80, 0x33, 0x57, 0x62, 0x63, 0xe4, 0x8c, 0xc7, 0xe4, 0x7d, 0xe8, 0x04,
	0xe9, 0xc9, 0x71, 0x3d, 0x0f, 0xc3, 0x49, 0x0c, 0x6d, 0x60, 0xe8, 0x9d, 0x0c, 0x1d, 0x64, 0xa0,
	0xfd, 0x9b, 0x01, 0xf7, 0x97, 0x8a, 0xa3, 0x69, 0x7f, 0x9a, 0x16, 0x20, 0xfd, 0x1f, 0x3f, 0x54,
	0x05, 0x78, 0x54, 0x53, 0x80, 0xcc, 0x81, 0x16, 0xae, 0x04, 0x39, 0x04, 0x05, 0x07, 0x4c, 0x49,
	0x75, 0xea, 0x7e, 0xf1, 0x61, 0x49, 0x8f, 0x56, 0xdc, 0xec, 0xef, 0xe0, 0xed, 0x0b, 0xdd, 0xe3,
	0x23, 0x37, 0xf4, 0x06, 0xbe, 0x2f, 0x98, 0xef, 0x26, 0x6c, 0x49, 0x0c, 0xc6, 0x8a, 0x18, 0xb0,
	0xae, 0xe1, 0x22, 0x70, 0xb2, 0x8e, 0x49, 0xad, 0x15, 0x40, 0xe8, 0x38, 0x43, 0x4a, 0x2d, 0x34,
	0xaa, 0x5a, 0xf8, 0xd3, 0x80, 0x77, 0x2f, 0x51, 0xbb, 0x4c, 0x54, 0x52, 0xbe, 0x9d, 0x44, 0xb5,
	0x0c, 0xcd, 0xcd, 0x32, 0x7c, 0x59, 0x86, 0x56, 0x95, 0x7b, 0x52, 0xf8, 0xd4, 0xa6, 0x99, 0x53,
	0xfb, 0x05, 0x7a, 0xd8, 0x89, 0x55, 0x72, 0x85, 0x58, 0x65, 0x6a, 0xa8, 0x88, 0x35, 0x03, 0x90,
	0xd0, 0xd1, 0x9a, 0x58, 0x3f, 0x28, 0x22, 0xde, 0x98, 0x6b, 0x45, 0xba, 0x7f, 0x19, 0xf0, 0x64,
	0x93, 0xef, 0x5d, 0x2a, 0xf9, 0x63, 0xb0, 0xdc, 0xb9, 0xaf, 0x8a, 0x30, 0x0b, 0xf4, 0x24, 0x93,
	0xc2, 0x71, 0x90, 0x5b, 0x68, 0xe9, 0xb4, 0xae, 0xfd, 0x66, 0x8d, 0xf6, 0xff, 0x30, 0xe0, 0x51,
	0x4d, 0xf1, 0x34, 0xf3, 0xe3, 0x35, 0x31, 0x3f, 0xff, 0xdf, 0x02, 0xdd, 0x8d, 0xb4, 0xbf, 0x86,
	0x3d, 0xca, 0xe6, 0x2a, 0xff, 0x5b, 0x3d, 0x3f, 0x2b, 0xa5, 0x56, 0x4d, 0x5d, 0x2a, 0xb5, 0x7d,
	0x0e, 0x0f, 0xd7, 0xee, 0xad, 0xe5, 0x69, 0xbc, 0x1e, 0xcf, 0xcf, 0xa1, 0x73, 0xee, 0x06, 0xcc,
	0xbb, 0x70, 0x05, 0xfe, 0x41, 0x94, 0x10, 0x68, 0x86, 0xae, 0x5e, 0x0f, 0x16, 0x4d, 0xff, 0x57,
	0x23, 0x85, 0x8f, 0xfe, 0x82, 0xa5, 0xd9, 0x5b, 0x34, 0x3b, 0xd8, 0x7f, 0x9b, 0x60, 0x15, 0x9d,
	0x23, 0x1f, 0x41, 0xf3, 0x7b, 0x1e, 0x66, 0x29, 0x75, 0x0e, 0x1f, 0xae, 0xf7, 0xf6, 0xe0, 0x2b,
	0x34, 0xd3, 0xd4, 0x89, 0x3c, 0x83, 0xed, 0x34, 0x09, 0x67, 0xce, 0x42, 0x3f, 0x99, 0xe9, 0x29,
	0x6e, 0xa7, 0xd8, 0x28, 0x85, 0x6a, 0x97, 0x51, 0xa3, 0x7e, 0x19, 0x7d, 0x06, 0x10, 0xe7, 0xfc,
	0xd5, 0x0a, 0x50, 0x8d, 0x2e, 0x09, 0x2c, 0xe7, 0x47, 0x2b, 0xae, 0x38, 0xaf, 0x7b, 0x18, 0x52,
	0x84, 0x3c, 0xf4, 0x9d, 0x20, 0xf2, 0x98, 0xe3, 0x2d, 0x84, 0x9b, 0xf0, 0x28, 0xec, 0x6d, 0x61,
	0xa2, 0x0d, 0xfa, 0x20, 0xb7, 0x9e, 0xa1, 0xf1, 0x95, 0xb6, 0xd9, 0x23, 0x68, 0xaa, 0x54, 0x48,
	0x17, 0xb6, 0xcf, 0xc7, 0xce, 0x60, 0x74, 0x32, 0xa6, 0xc3, 0xc9, 0xe9, 0x59, 0xf7, 0x0d, 0x02,
	0xf0, 0xe6, 0xe5, 0x64, 0x30, 0x19, 0x1e, 0x77, 0x0d, 0xb2, 0x07, 0xe4, 0x82, 0x8e, 0x2f, 0xc6,
	0x74, 0x32, 0x1c, 0x9f, 0x0f, 0x46, 0xce, 0xe5, 0xe9, 0x80, 0x7e, 0xd1, 0x35, 0x49, 0x07, 0xe0,
	0xcb, 0xc1, 0x90, 0xea, 0x73, 0xc3, 0xfe, 0xd7, 0x28, 0x97, 0xc7, 0x84, 0x05, 0xf1, 0x5c, 0x3d,
	0x80, 0xcf, 0x61, 0x97, 0x7b, 0x28, 0x09, 0x7e, 0xc5, 0x71, 0xf4, 0xfd, 0x79, 0xf4, 0xad, 0xee,
	0x47, 0xa7, 0x84, 0x4f, 0x10, 0x5d, 0xda, 0xc3, 0xe6, 0xf2, 0x1e, 0x5e, 0x1d, 0x39, 0xf3, 0x6e,
	0x46, 0x0e, 0x9f, 0xc1, 0xb6, 0xc7, 0xe4, 0x54, 0xf0, 0xb8, 0xa8, 0x94, 0x45, 0xab, 0x90, 0x7d,
	0x06, 0xa4, 0x9c, 0xa7, 0x38, 0x92, 0x3c, 0x89, 0xc4, 0x35, 0x76, 0xc9, 0xca, 0x85, 0x2c, 0x37,
	0xae, 0x96, 0xbc, 0x02, 0xb4, 0xf4, 0xb5, 0x09, 0x74, 0x5f, 0x71, 0x39, 0x8d, 0x70, 0x5c, 0xf3,
	0x29, 0xb2, 0x19, 0xdc, 0xab, 0x60, 0x1b, 0x26, 0xc0, 0x7c, 0x8d, 0x09, 0x50, 0xf3, 0xc8, 0xa5,
	0x93, 0x01, 0x69, 0x09, 0x5b, 0xb4, 0xc5, 0x65, 0xe6, 0x7c, 0xf8, 0x8f, 0x09, 0xad, 0x22, 0xf1,
	0x23, 0xb0, 0x8a, 0x98, 0xa4, 0xa4, 0xbe, 0xca, 0xad, 0xdf, 0xaf, 0x33, 0x69, 0x8a, 0xa7, 0xd0,
	0xae, 0x6c, 0x5d, 0xf2, 0xb8, 0x70, 0x5d, 0xff, 0xa1, 0xd2, 0x7f, 0xa7, 0xde, 0xa8, 0x6f, 0xfa,
	0x06, 0xee, 0xad, 0x3d, 0x7c, 0xe4, 0x59, 0xf5, 0x93, 0xda, 0x8d, 0xd2, 0xb7, 0x6f, 0x72, 0xd1,
	0x77, 0x4f, 0xd4, 0x0f, 0xb8, 0xa5, 0x57, 0x86, 0x3c, 0xad, 0xb4, 0xaa, 0xee, 0x5d, 0xeb, 0xef,
	0x6f, 0x76, 0xc8, 0x6e, 0xfd, 0x2f, 0x00, 0x00, 0xff, 0xff, 0xb0, 0x80, 0x24, 0xe3, 0xa1, 0x0a,
	0x00, 0x00,
}
