// Code generated by protoc-gen-go.
// source: doorman.proto
// DO NOT EDIT!

/*
Package doorman is a generated protocol buffer package.

It is generated from these files:
	doorman.proto

It has these top-level messages:
	Lease
	ResourceRequest
	GetCapacityRequest
	ResourceResponse
	Mastership
	GetCapacityResponse
	PriorityBandAggregate
	ServerCapacityResourceRequest
	GetServerCapacityRequest
	ServerCapacityResourceResponse
	GetServerCapacityResponse
	ReleaseCapacityRequest
	ReleaseCapacityResponse
	NamedParameter
	Algorithm
	ResourceTemplate
	ResourceRepository
	DiscoveryRequest
	DiscoveryResponse
*/
package doorman

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Algorithm_Kind int32

const (
	Algorithm_NO_ALGORITHM       Algorithm_Kind = 0
	Algorithm_STATIC             Algorithm_Kind = 1
	Algorithm_PROPORTIONAL_SHARE Algorithm_Kind = 2
	Algorithm_FAIR_SHARE         Algorithm_Kind = 3
)

var Algorithm_Kind_name = map[int32]string{
	0: "NO_ALGORITHM",
	1: "STATIC",
	2: "PROPORTIONAL_SHARE",
	3: "FAIR_SHARE",
}
var Algorithm_Kind_value = map[string]int32{
	"NO_ALGORITHM":       0,
	"STATIC":             1,
	"PROPORTIONAL_SHARE": 2,
	"FAIR_SHARE":         3,
}

func (x Algorithm_Kind) String() string {
	return proto.EnumName(Algorithm_Kind_name, int32(x))
}

func (x *Algorithm_Kind) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Algorithm_Kind_value, data, "Algorithm_Kind")
	if err != nil {
		return err
	}
	*x = Algorithm_Kind(value)
	return nil
}

func (Algorithm_Kind) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{14, 0} }

// Encapsulates a lease on capacity with a expiry_time in seconds
// since the epoch.
type Lease struct {
	ExpiryTime      int64   `protobuf:"varint,1,opt,name=expiry_time" json:"expiry_time,omitempty"`
	RefreshInterval int64   `protobuf:"varint,2,opt,name=refresh_interval" json:"refresh_interval,omitempty"`
	Capacity        float64 `protobuf:"fixed64,3,opt,name=capacity" json:"capacity,omitempty"`
}

func (m *Lease) Reset()                    { *m = Lease{} }
func (m *Lease) String() string            { return proto.CompactTextString(m) }
func (*Lease) ProtoMessage()               {}
func (*Lease) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Encapsulates the information we need to send to get capacity for a
// single resource.
type ResourceRequest struct {
	ResourceId string  `protobuf:"bytes,1,opt,name=resource_id" json:"resource_id,omitempty"`
	Priority   int64   `protobuf:"varint,2,opt,name=priority" json:"priority,omitempty"`
	Has        *Lease  `protobuf:"bytes,3,opt,name=has" json:"has,omitempty"`
	Wants      float64 `protobuf:"fixed64,4,opt,name=wants" json:"wants,omitempty"`
}

func (m *ResourceRequest) Reset()                    { *m = ResourceRequest{} }
func (m *ResourceRequest) String() string            { return proto.CompactTextString(m) }
func (*ResourceRequest) ProtoMessage()               {}
func (*ResourceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ResourceRequest) GetHas() *Lease {
	if m != nil {
		return m.Has
	}
	return nil
}

// The GetCapacityRequest contains the identifier of the client making
// the request and a list of single resource capacity request protocol
// buffers.
type GetCapacityRequest struct {
	ClientId string             `protobuf:"bytes,1,opt,name=client_id" json:"client_id,omitempty"`
	Resource []*ResourceRequest `protobuf:"bytes,2,rep,name=resource" json:"resource,omitempty"`
}

func (m *GetCapacityRequest) Reset()                    { *m = GetCapacityRequest{} }
func (m *GetCapacityRequest) String() string            { return proto.CompactTextString(m) }
func (*GetCapacityRequest) ProtoMessage()               {}
func (*GetCapacityRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *GetCapacityRequest) GetResource() []*ResourceRequest {
	if m != nil {
		return m.Resource
	}
	return nil
}

// Contains the capacity allocated by the server for a single
// resource.
type ResourceResponse struct {
	ResourceId   string  `protobuf:"bytes,1,opt,name=resource_id" json:"resource_id,omitempty"`
	Gets         *Lease  `protobuf:"bytes,2,opt,name=gets" json:"gets,omitempty"`
	SafeCapacity float64 `protobuf:"fixed64,3,opt,name=safe_capacity" json:"safe_capacity,omitempty"`
}

func (m *ResourceResponse) Reset()                    { *m = ResourceResponse{} }
func (m *ResourceResponse) String() string            { return proto.CompactTextString(m) }
func (*ResourceResponse) ProtoMessage()               {}
func (*ResourceResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ResourceResponse) GetGets() *Lease {
	if m != nil {
		return m.Gets
	}
	return nil
}

// This message type is used when the server wants to convey the
// address of a master. If the the master_address field
// is not there that means that the server wants to tell us who
// the master is, but it doesn't know.
type Mastership struct {
	MasterAddress string `protobuf:"bytes,1,opt,name=master_address" json:"master_address,omitempty"`
}

func (m *Mastership) Reset()                    { *m = Mastership{} }
func (m *Mastership) String() string            { return proto.CompactTextString(m) }
func (*Mastership) ProtoMessage()               {}
func (*Mastership) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

// The response to a GetCapacity request is a list of protocol buffers
// specifying the capacity for a single resource.
// If the mastership field is there the server is telling us that it is
// not the master. The new master is in the mastership message, unless
// the server does not know who the master is, in which case the
// mastership field will be there, but the master_address field in it will
// be empty.
type GetCapacityResponse struct {
	Response   []*ResourceResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
	Mastership *Mastership         `protobuf:"bytes,2,opt,name=mastership" json:"mastership,omitempty"`
}

func (m *GetCapacityResponse) Reset()                    { *m = GetCapacityResponse{} }
func (m *GetCapacityResponse) String() string            { return proto.CompactTextString(m) }
func (*GetCapacityResponse) ProtoMessage()               {}
func (*GetCapacityResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *GetCapacityResponse) GetResponse() []*ResourceResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *GetCapacityResponse) GetMastership() *Mastership {
	if m != nil {
		return m.Mastership
	}
	return nil
}

type PriorityBandAggregate struct {
	Priority   int64   `protobuf:"varint,1,opt,name=priority" json:"priority,omitempty"`
	NumClients int64   `protobuf:"varint,2,opt,name=num_clients" json:"num_clients,omitempty"`
	Wants      float64 `protobuf:"fixed64,3,opt,name=wants" json:"wants,omitempty"`
}

func (m *PriorityBandAggregate) Reset()                    { *m = PriorityBandAggregate{} }
func (m *PriorityBandAggregate) String() string            { return proto.CompactTextString(m) }
func (*PriorityBandAggregate) ProtoMessage()               {}
func (*PriorityBandAggregate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type ServerCapacityResourceRequest struct {
	ResourceId string                   `protobuf:"bytes,1,opt,name=resource_id" json:"resource_id,omitempty"`
	Has        *Lease                   `protobuf:"bytes,2,opt,name=has" json:"has,omitempty"`
	Wants      []*PriorityBandAggregate `protobuf:"bytes,3,rep,name=wants" json:"wants,omitempty"`
}

func (m *ServerCapacityResourceRequest) Reset()                    { *m = ServerCapacityResourceRequest{} }
func (m *ServerCapacityResourceRequest) String() string            { return proto.CompactTextString(m) }
func (*ServerCapacityResourceRequest) ProtoMessage()               {}
func (*ServerCapacityResourceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *ServerCapacityResourceRequest) GetHas() *Lease {
	if m != nil {
		return m.Has
	}
	return nil
}

func (m *ServerCapacityResourceRequest) GetWants() []*PriorityBandAggregate {
	if m != nil {
		return m.Wants
	}
	return nil
}

type GetServerCapacityRequest struct {
	ServerId string                           `protobuf:"bytes,1,opt,name=server_id" json:"server_id,omitempty"`
	Resource []*ServerCapacityResourceRequest `protobuf:"bytes,2,rep,name=resource" json:"resource,omitempty"`
}

func (m *GetServerCapacityRequest) Reset()                    { *m = GetServerCapacityRequest{} }
func (m *GetServerCapacityRequest) String() string            { return proto.CompactTextString(m) }
func (*GetServerCapacityRequest) ProtoMessage()               {}
func (*GetServerCapacityRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *GetServerCapacityRequest) GetResource() []*ServerCapacityResourceRequest {
	if m != nil {
		return m.Resource
	}
	return nil
}

type ServerCapacityResourceResponse struct {
	ResourceId   string     `protobuf:"bytes,1,opt,name=resource_id" json:"resource_id,omitempty"`
	Gets         *Lease     `protobuf:"bytes,2,opt,name=gets" json:"gets,omitempty"`
	Algorithm    *Algorithm `protobuf:"bytes,3,opt,name=algorithm" json:"algorithm,omitempty"`
	SafeCapacity float64    `protobuf:"fixed64,4,opt,name=safe_capacity" json:"safe_capacity,omitempty"`
}

func (m *ServerCapacityResourceResponse) Reset()                    { *m = ServerCapacityResourceResponse{} }
func (m *ServerCapacityResourceResponse) String() string            { return proto.CompactTextString(m) }
func (*ServerCapacityResourceResponse) ProtoMessage()               {}
func (*ServerCapacityResourceResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *ServerCapacityResourceResponse) GetGets() *Lease {
	if m != nil {
		return m.Gets
	}
	return nil
}

func (m *ServerCapacityResourceResponse) GetAlgorithm() *Algorithm {
	if m != nil {
		return m.Algorithm
	}
	return nil
}

// The response to a GetServerCapacity request is a list of protocol buffers
// specifying the capacity for a single resource.
// If the mastership field is there the server is telling us that it is
// not the master. The new master is in the mastership message, unless
// the server does not know who the master is, in which case the
// mastership field will be there, but the master_address field in it will
// be empty.
type GetServerCapacityResponse struct {
	Response   []*ServerCapacityResourceResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
	Mastership *Mastership                       `protobuf:"bytes,2,opt,name=mastership" json:"mastership,omitempty"`
}

func (m *GetServerCapacityResponse) Reset()                    { *m = GetServerCapacityResponse{} }
func (m *GetServerCapacityResponse) String() string            { return proto.CompactTextString(m) }
func (*GetServerCapacityResponse) ProtoMessage()               {}
func (*GetServerCapacityResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *GetServerCapacityResponse) GetResponse() []*ServerCapacityResourceResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *GetServerCapacityResponse) GetMastership() *Mastership {
	if m != nil {
		return m.Mastership
	}
	return nil
}

// The ReleaseCapacity RPC instructs the server to release all leases
// that this client has on one or more resources. The lease is expected
// to expire as part of this RPC, so the client should not use the resource
// anymore.
type ReleaseCapacityRequest struct {
	ClientId   string   `protobuf:"bytes,1,opt,name=client_id" json:"client_id,omitempty"`
	ResourceId []string `protobuf:"bytes,2,rep,name=resource_id" json:"resource_id,omitempty"`
}

func (m *ReleaseCapacityRequest) Reset()                    { *m = ReleaseCapacityRequest{} }
func (m *ReleaseCapacityRequest) String() string            { return proto.CompactTextString(m) }
func (*ReleaseCapacityRequest) ProtoMessage()               {}
func (*ReleaseCapacityRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

// A ReleaseCapacity RPC can only fail if the server we are talking to
// is not the master. In that case the mastership field indicates who
// the master is (if we know, if we don't know the mastership field will
// be there but the master_addres field inside mastership will
// not be there).
type ReleaseCapacityResponse struct {
	Mastership *Mastership `protobuf:"bytes,1,opt,name=mastership" json:"mastership,omitempty"`
}

func (m *ReleaseCapacityResponse) Reset()                    { *m = ReleaseCapacityResponse{} }
func (m *ReleaseCapacityResponse) String() string            { return proto.CompactTextString(m) }
func (*ReleaseCapacityResponse) ProtoMessage()               {}
func (*ReleaseCapacityResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *ReleaseCapacityResponse) GetMastership() *Mastership {
	if m != nil {
		return m.Mastership
	}
	return nil
}

// NamedParameter encapsulates a name/value pair which is used to
// configure an Algorithm (see below).
type NamedParameter struct {
	Name  string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *NamedParameter) Reset()                    { *m = NamedParameter{} }
func (m *NamedParameter) String() string            { return proto.CompactTextString(m) }
func (*NamedParameter) ProtoMessage()               {}
func (*NamedParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

type Algorithm struct {
	Kind Algorithm_Kind `protobuf:"varint,1,opt,name=kind,enum=doorman.Algorithm_Kind" json:"kind,omitempty"`
	// How long should the lease be, in seconds.
	LeaseLength int64 `protobuf:"varint,2,opt,name=lease_length" json:"lease_length,omitempty"`
	// How many seconds should the client wait until refreshing its
	// lease.
	RefreshInterval int64             `protobuf:"varint,3,opt,name=refresh_interval" json:"refresh_interval,omitempty"`
	Parameters      []*NamedParameter `protobuf:"bytes,4,rep,name=parameters" json:"parameters,omitempty"`
	// By default the learning mode duration is the lease length,
	// however if you want to live dangerously, and assume that
	// clients are living up to their responsibility to contact
	// the server every refresh_interval, you can specify a shorter
	// learning mode here. You can also specify a longer learning
	// mode duration (longer than the lease length), but then you
	// are a muppet (or you do not trust the clients, in which case
	// you need to fix the client implementation).
	LearningModeDuration int64 `protobuf:"varint,5,opt,name=learning_mode_duration" json:"learning_mode_duration,omitempty"`
}

func (m *Algorithm) Reset()                    { *m = Algorithm{} }
func (m *Algorithm) String() string            { return proto.CompactTextString(m) }
func (*Algorithm) ProtoMessage()               {}
func (*Algorithm) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *Algorithm) GetParameters() []*NamedParameter {
	if m != nil {
		return m.Parameters
	}
	return nil
}

// ResourceTemplate is used to instantiate the actual configuration
// for a resource based on a match with the identifier_glob glob.
type ResourceTemplate struct {
	// Glob used to match actual resources.
	IdentifierGlob string `protobuf:"bytes,1,opt,name=identifier_glob" json:"identifier_glob,omitempty"`
	// Capacity in service units
	Capacity float64 `protobuf:"fixed64,2,opt,name=capacity" json:"capacity,omitempty"`
	// Algorithm used to divide capacity between clients.
	Algorithm *Algorithm `protobuf:"bytes,3,opt,name=algorithm" json:"algorithm,omitempty"`
	// Capacity to use in "safe" mode.
	// You can set this to a number and then the client will use that number
	// as the capacity in case it cannot refresh its lease.
	// If this field is absent the system returns a dynamic safe capacity in
	// the response, which is the available capacity divided by the number of
	// clients that the server knows about.
	SafeCapacity float64 `protobuf:"fixed64,4,opt,name=safe_capacity" json:"safe_capacity,omitempty"`
	// Description of the resource.
	Description string `protobuf:"bytes,5,opt,name=description" json:"description,omitempty"`
}

func (m *ResourceTemplate) Reset()                    { *m = ResourceTemplate{} }
func (m *ResourceTemplate) String() string            { return proto.CompactTextString(m) }
func (*ResourceTemplate) ProtoMessage()               {}
func (*ResourceTemplate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *ResourceTemplate) GetAlgorithm() *Algorithm {
	if m != nil {
		return m.Algorithm
	}
	return nil
}

// The resource configuration consists of a list of templates.
type ResourceRepository struct {
	// List of ResourceTemplates specifying available resources. Order
	// of elements in this list is significant: it will be used to match
	// incoming requests. A template for * should be the last element.
	Resources []*ResourceTemplate `protobuf:"bytes,1,rep,name=resources" json:"resources,omitempty"`
}

func (m *ResourceRepository) Reset()                    { *m = ResourceRepository{} }
func (m *ResourceRepository) String() string            { return proto.CompactTextString(m) }
func (*ResourceRepository) ProtoMessage()               {}
func (*ResourceRepository) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *ResourceRepository) GetResources() []*ResourceTemplate {
	if m != nil {
		return m.Resources
	}
	return nil
}

// The request to obtain the master's address.
type DiscoveryRequest struct {
}

func (m *DiscoveryRequest) Reset()                    { *m = DiscoveryRequest{} }
func (m *DiscoveryRequest) String() string            { return proto.CompactTextString(m) }
func (*DiscoveryRequest) ProtoMessage()               {}
func (*DiscoveryRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

// The response containing the master's address.
type DiscoveryResponse struct {
	Mastership *Mastership `protobuf:"bytes,1,opt,name=mastership" json:"mastership,omitempty"`
	IsMaster   bool        `protobuf:"varint,2,opt,name=is_master" json:"is_master,omitempty"`
}

func (m *DiscoveryResponse) Reset()                    { *m = DiscoveryResponse{} }
func (m *DiscoveryResponse) String() string            { return proto.CompactTextString(m) }
func (*DiscoveryResponse) ProtoMessage()               {}
func (*DiscoveryResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *DiscoveryResponse) GetMastership() *Mastership {
	if m != nil {
		return m.Mastership
	}
	return nil
}

func init() {
	proto.RegisterType((*Lease)(nil), "doorman.Lease")
	proto.RegisterType((*ResourceRequest)(nil), "doorman.ResourceRequest")
	proto.RegisterType((*GetCapacityRequest)(nil), "doorman.GetCapacityRequest")
	proto.RegisterType((*ResourceResponse)(nil), "doorman.ResourceResponse")
	proto.RegisterType((*Mastership)(nil), "doorman.Mastership")
	proto.RegisterType((*GetCapacityResponse)(nil), "doorman.GetCapacityResponse")
	proto.RegisterType((*PriorityBandAggregate)(nil), "doorman.PriorityBandAggregate")
	proto.RegisterType((*ServerCapacityResourceRequest)(nil), "doorman.ServerCapacityResourceRequest")
	proto.RegisterType((*GetServerCapacityRequest)(nil), "doorman.GetServerCapacityRequest")
	proto.RegisterType((*ServerCapacityResourceResponse)(nil), "doorman.ServerCapacityResourceResponse")
	proto.RegisterType((*GetServerCapacityResponse)(nil), "doorman.GetServerCapacityResponse")
	proto.RegisterType((*ReleaseCapacityRequest)(nil), "doorman.ReleaseCapacityRequest")
	proto.RegisterType((*ReleaseCapacityResponse)(nil), "doorman.ReleaseCapacityResponse")
	proto.RegisterType((*NamedParameter)(nil), "doorman.NamedParameter")
	proto.RegisterType((*Algorithm)(nil), "doorman.Algorithm")
	proto.RegisterType((*ResourceTemplate)(nil), "doorman.ResourceTemplate")
	proto.RegisterType((*ResourceRepository)(nil), "doorman.ResourceRepository")
	proto.RegisterType((*DiscoveryRequest)(nil), "doorman.DiscoveryRequest")
	proto.RegisterType((*DiscoveryResponse)(nil), "doorman.DiscoveryResponse")
	proto.RegisterEnum("doorman.Algorithm_Kind", Algorithm_Kind_name, Algorithm_Kind_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion3

// Client API for Capacity service

type CapacityClient interface {
	// Used by clients to discover the master Doorman server.
	Discovery(ctx context.Context, in *DiscoveryRequest, opts ...grpc.CallOption) (*DiscoveryResponse, error)
	// Used by clients to obtain capacity from Doorman.
	GetCapacity(ctx context.Context, in *GetCapacityRequest, opts ...grpc.CallOption) (*GetCapacityResponse, error)
	// Used by Doorman servers to get capacity on behalf of their clients from
	// lower level Doorman servers.
	GetServerCapacity(ctx context.Context, in *GetServerCapacityRequest, opts ...grpc.CallOption) (*GetServerCapacityResponse, error)
	// Used by clients to release any capacity they have for one or more
	// resources.
	ReleaseCapacity(ctx context.Context, in *ReleaseCapacityRequest, opts ...grpc.CallOption) (*ReleaseCapacityResponse, error)
}

type capacityClient struct {
	cc *grpc.ClientConn
}

func NewCapacityClient(cc *grpc.ClientConn) CapacityClient {
	return &capacityClient{cc}
}

func (c *capacityClient) Discovery(ctx context.Context, in *DiscoveryRequest, opts ...grpc.CallOption) (*DiscoveryResponse, error) {
	out := new(DiscoveryResponse)
	err := grpc.Invoke(ctx, "/doorman.Capacity/Discovery", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *capacityClient) GetCapacity(ctx context.Context, in *GetCapacityRequest, opts ...grpc.CallOption) (*GetCapacityResponse, error) {
	out := new(GetCapacityResponse)
	err := grpc.Invoke(ctx, "/doorman.Capacity/GetCapacity", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *capacityClient) GetServerCapacity(ctx context.Context, in *GetServerCapacityRequest, opts ...grpc.CallOption) (*GetServerCapacityResponse, error) {
	out := new(GetServerCapacityResponse)
	err := grpc.Invoke(ctx, "/doorman.Capacity/GetServerCapacity", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *capacityClient) ReleaseCapacity(ctx context.Context, in *ReleaseCapacityRequest, opts ...grpc.CallOption) (*ReleaseCapacityResponse, error) {
	out := new(ReleaseCapacityResponse)
	err := grpc.Invoke(ctx, "/doorman.Capacity/ReleaseCapacity", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Capacity service

type CapacityServer interface {
	// Used by clients to discover the master Doorman server.
	Discovery(context.Context, *DiscoveryRequest) (*DiscoveryResponse, error)
	// Used by clients to obtain capacity from Doorman.
	GetCapacity(context.Context, *GetCapacityRequest) (*GetCapacityResponse, error)
	// Used by Doorman servers to get capacity on behalf of their clients from
	// lower level Doorman servers.
	GetServerCapacity(context.Context, *GetServerCapacityRequest) (*GetServerCapacityResponse, error)
	// Used by clients to release any capacity they have for one or more
	// resources.
	ReleaseCapacity(context.Context, *ReleaseCapacityRequest) (*ReleaseCapacityResponse, error)
}

func RegisterCapacityServer(s *grpc.Server, srv CapacityServer) {
	s.RegisterService(&_Capacity_serviceDesc, srv)
}

func _Capacity_Discovery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiscoveryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CapacityServer).Discovery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/doorman.Capacity/Discovery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CapacityServer).Discovery(ctx, req.(*DiscoveryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Capacity_GetCapacity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCapacityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CapacityServer).GetCapacity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/doorman.Capacity/GetCapacity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CapacityServer).GetCapacity(ctx, req.(*GetCapacityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Capacity_GetServerCapacity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetServerCapacityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CapacityServer).GetServerCapacity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/doorman.Capacity/GetServerCapacity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CapacityServer).GetServerCapacity(ctx, req.(*GetServerCapacityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Capacity_ReleaseCapacity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReleaseCapacityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CapacityServer).ReleaseCapacity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/doorman.Capacity/ReleaseCapacity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CapacityServer).ReleaseCapacity(ctx, req.(*ReleaseCapacityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Capacity_serviceDesc = grpc.ServiceDesc{
	ServiceName: "doorman.Capacity",
	HandlerType: (*CapacityServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Discovery",
			Handler:    _Capacity_Discovery_Handler,
		},
		{
			MethodName: "GetCapacity",
			Handler:    _Capacity_GetCapacity_Handler,
		},
		{
			MethodName: "GetServerCapacity",
			Handler:    _Capacity_GetServerCapacity_Handler,
		},
		{
			MethodName: "ReleaseCapacity",
			Handler:    _Capacity_ReleaseCapacity_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: fileDescriptor0,
}

func init() { proto.RegisterFile("doorman.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 825 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xa4, 0x56, 0xdf, 0x73, 0xdb, 0x44,
	0x10, 0x46, 0xb1, 0x53, 0xa2, 0x75, 0xe2, 0x2a, 0x17, 0x9a, 0xa8, 0x6e, 0x09, 0x41, 0x43, 0x69,
	0x86, 0xd2, 0x3c, 0x84, 0x17, 0x78, 0xc3, 0x29, 0x90, 0x64, 0x48, 0xe2, 0x8c, 0xe2, 0x27, 0x86,
	0x19, 0xcd, 0xd5, 0xda, 0xc8, 0x37, 0xd5, 0x2f, 0xee, 0xce, 0x81, 0x3c, 0xc1, 0x9f, 0x00, 0xff,
	0x16, 0xff, 0x13, 0x33, 0xcc, 0x9d, 0x4e, 0x92, 0x63, 0xc9, 0x2d, 0xa1, 0x6f, 0x96, 0x76, 0xef,
	0xdb, 0xef, 0xdb, 0xfd, 0x6e, 0x65, 0xd8, 0x08, 0xb3, 0x8c, 0x27, 0x34, 0x3d, 0xc8, 0x79, 0x26,
	0x33, 0xf2, 0xa1, 0x79, 0xf4, 0x4e, 0x60, 0xf5, 0x0c, 0xa9, 0x40, 0xb2, 0x05, 0x3d, 0xfc, 0x2d,
	0x67, 0xfc, 0x36, 0x90, 0x2c, 0x41, 0xd7, 0xda, 0xb3, 0xf6, 0x3b, 0xc4, 0x05, 0x87, 0xe3, 0x35,
	0x47, 0x31, 0x0d, 0x58, 0x2a, 0x91, 0xdf, 0xd0, 0xd8, 0x5d, 0xd1, 0x11, 0x07, 0xd6, 0x26, 0x34,
	0xa7, 0x13, 0x26, 0x6f, 0xdd, 0xce, 0x9e, 0xb5, 0x6f, 0x79, 0x21, 0x3c, 0xf4, 0x51, 0x64, 0x33,
	0x3e, 0x41, 0x1f, 0x7f, 0x99, 0xa1, 0x90, 0x0a, 0x93, 0x9b, 0x57, 0x01, 0x0b, 0x35, 0xa6, 0xad,
	0x4e, 0xe6, 0x9c, 0x65, 0x5c, 0x9d, 0x2c, 0xb0, 0x9e, 0x40, 0x67, 0x4a, 0x85, 0x86, 0xe9, 0x1d,
	0xf6, 0x0f, 0x4a, 0xa6, 0x05, 0xaf, 0x0d, 0x58, 0xfd, 0x95, 0xa6, 0x52, 0xb8, 0x5d, 0x5d, 0xe5,
	0x0a, 0xc8, 0x31, 0xca, 0x57, 0xa6, 0x74, 0x59, 0x68, 0x13, 0xec, 0x49, 0xcc, 0x30, 0x95, 0x75,
	0x99, 0x2f, 0x60, 0xad, 0xac, 0xed, 0xae, 0xec, 0x75, 0xf6, 0x7b, 0x87, 0x6e, 0x85, 0xbc, 0xc0,
	0xd3, 0xfb, 0x19, 0x9c, 0xfa, 0x95, 0xc8, 0xb3, 0xb4, 0xe8, 0x47, 0x93, 0xfb, 0x53, 0xe8, 0x46,
	0x28, 0x85, 0xe6, 0xdd, 0xa4, 0xfa, 0x08, 0x36, 0x04, 0xbd, 0xc6, 0x60, 0xa1, 0x31, 0x9f, 0x01,
	0x9c, 0x53, 0x21, 0x91, 0x8b, 0x29, 0xcb, 0xc9, 0x36, 0xf4, 0x13, 0xfd, 0x14, 0xd0, 0x30, 0xe4,
	0x28, 0x44, 0x01, 0xed, 0xbd, 0x81, 0xad, 0x3b, 0xc2, 0x0c, 0x8d, 0x17, 0x5a, 0x86, 0xfe, 0xed,
	0x5a, 0x5a, 0xc6, 0xe3, 0x16, 0x19, 0x26, 0xf9, 0x39, 0x40, 0x52, 0x55, 0x32, 0x24, 0xb7, 0xaa,
	0xf4, 0x9a, 0x84, 0x77, 0x0e, 0x8f, 0x2e, 0xcd, 0x0c, 0x8e, 0x68, 0x1a, 0x0e, 0xa3, 0x88, 0x63,
	0x44, 0x25, 0xde, 0x19, 0x4e, 0x61, 0x81, 0x2d, 0xe8, 0xa5, 0xb3, 0x24, 0x28, 0xda, 0x2b, 0xcc,
	0xc4, 0xaa, 0xa1, 0x14, 0x0a, 0xff, 0xb0, 0xe0, 0xe3, 0x2b, 0xe4, 0x37, 0xc8, 0xe7, 0xf8, 0xbf,
	0xdb, 0x09, 0x66, 0xee, 0xed, 0xcd, 0x7c, 0x59, 0x97, 0x50, 0xaa, 0x77, 0xab, 0x70, 0x2b, 0x71,
	0x2f, 0x02, 0xf7, 0x18, 0xe5, 0x22, 0x89, 0xca, 0x1d, 0x42, 0x07, 0xea, 0xd2, 0x5f, 0x37, 0xdc,
	0xf1, 0x79, 0x55, 0xe0, 0xad, 0x4a, 0xbc, 0xbf, 0x2c, 0xd8, 0x5d, 0x96, 0xf1, 0xff, 0xad, 0xf3,
	0x0c, 0x6c, 0x1a, 0x47, 0x4a, 0xd7, 0x34, 0x31, 0x17, 0x81, 0x54, 0x29, 0xc3, 0x32, 0xd2, 0x74,
	0x58, 0x71, 0x29, 0x7e, 0x87, 0xc7, 0x2d, 0xe2, 0x0d, 0x9b, 0x6f, 0x1a, 0x0e, 0x7a, 0xfe, 0x4e,
	0xa9, 0xf7, 0xf5, 0xd3, 0xb7, 0xb0, 0xed, 0x63, 0xac, 0x94, 0xfc, 0x87, 0x9b, 0xb9, 0xd0, 0x1e,
	0xd5, 0x7e, 0xdb, 0x3b, 0x82, 0x9d, 0x06, 0x42, 0x2b, 0x0b, 0x6b, 0x39, 0x8b, 0x97, 0xd0, 0xbf,
	0xa0, 0x09, 0x86, 0x97, 0x94, 0xd3, 0x04, 0x25, 0x72, 0xb2, 0x0e, 0xdd, 0x94, 0x9a, 0x6d, 0x66,
	0x2b, 0xd7, 0xde, 0xd0, 0x78, 0x86, 0x5a, 0x89, 0xed, 0xfd, 0x63, 0x81, 0x5d, 0xb7, 0xf6, 0x19,
	0x74, 0xdf, 0xb0, 0xb4, 0xe0, 0xd8, 0x3f, 0xdc, 0x69, 0x36, 0xff, 0xe0, 0x47, 0x96, 0x86, 0xe4,
	0x23, 0x58, 0xd7, 0x2c, 0x83, 0x18, 0xd3, 0x48, 0x4e, 0xcd, 0x7d, 0x68, 0xdb, 0x93, 0x1d, 0x1d,
	0x79, 0x01, 0x90, 0x97, 0x74, 0xd4, 0x0e, 0x53, 0xfd, 0xaf, 0xc1, 0x17, 0xe8, 0xee, 0xc2, 0x76,
	0x8c, 0x94, 0xa7, 0x2c, 0x8d, 0x82, 0x24, 0x0b, 0x31, 0x08, 0x67, 0x9c, 0x4a, 0x96, 0xa5, 0xee,
	0xaa, 0x02, 0xf3, 0xce, 0xa0, 0xab, 0x49, 0x38, 0xb0, 0x7e, 0x31, 0x0a, 0x86, 0x67, 0xc7, 0x23,
	0xff, 0x74, 0x7c, 0x72, 0xee, 0x7c, 0x40, 0x00, 0x1e, 0x5c, 0x8d, 0x87, 0xe3, 0xd3, 0x57, 0x8e,
	0x45, 0xb6, 0x81, 0x5c, 0xfa, 0xa3, 0xcb, 0x91, 0x3f, 0x3e, 0x1d, 0x5d, 0x0c, 0xcf, 0x82, 0xab,
	0x93, 0xa1, 0xff, 0xbd, 0xb3, 0x42, 0xfa, 0x00, 0x3f, 0x0c, 0x4f, 0x7d, 0xf3, 0xdc, 0xf1, 0xfe,
	0xb4, 0xea, 0xb5, 0x37, 0xc6, 0x24, 0x8f, 0xd5, 0x02, 0xd8, 0x81, 0x87, 0x2c, 0xc4, 0x54, 0xb2,
	0x6b, 0x86, 0x3c, 0x88, 0xe2, 0xec, 0x75, 0xbd, 0xb6, 0x2b, 0xd7, 0x29, 0xd1, 0xd6, 0xfb, 0x79,
	0x56, 0xb9, 0x20, 0x44, 0x31, 0xe1, 0x2c, 0xaf, 0x04, 0x2a, 0x17, 0x90, 0xda, 0x84, 0x79, 0x26,
	0x98, 0xcc, 0xf8, 0x2d, 0xf9, 0x12, 0xec, 0xd2, 0x30, 0x62, 0xe9, 0x12, 0x2c, 0x15, 0x78, 0x04,
	0x9c, 0xef, 0x98, 0x98, 0x64, 0x37, 0xc8, 0x4b, 0x17, 0x7a, 0x23, 0xd8, 0x9c, 0x7b, 0x77, 0x4f,
	0x5f, 0x29, 0x0f, 0x33, 0x11, 0x14, 0xb9, 0x5a, 0xfb, 0xda, 0xe1, 0xdf, 0x2b, 0xb0, 0x56, 0x1a,
	0x95, 0x1c, 0x81, 0x5d, 0xa1, 0x93, 0x9a, 0xd9, 0x22, 0x8b, 0xc1, 0xa0, 0x2d, 0x64, 0xc8, 0x9c,
	0x40, 0x6f, 0x6e, 0xfd, 0x93, 0x27, 0x55, 0x6a, 0xf3, 0x6b, 0x37, 0x78, 0xda, 0x1e, 0x34, 0x48,
	0x3f, 0xc1, 0x66, 0x63, 0x19, 0x90, 0x4f, 0xe7, 0x8f, 0xb4, 0x6e, 0xc9, 0x81, 0xf7, 0xb6, 0x14,
	0x83, 0x3d, 0x56, 0xdf, 0xf8, 0x3b, 0xb7, 0x94, 0x7c, 0x32, 0x37, 0x89, 0xb6, 0x0d, 0x30, 0xd8,
	0x5b, 0x9e, 0x50, 0xa0, 0xbe, 0x7e, 0xa0, 0xff, 0x93, 0x7c, 0xf5, 0x6f, 0x00, 0x00, 0x00, 0xff,
	0xff, 0xf7, 0xb7, 0x2b, 0xab, 0xa4, 0x08, 0x00, 0x00,
}
